### **【仕様書】エレメント診断システム**

#### **1. 概要**
本システムは、ユーザーの性格や価値観を「火・地・風・水」の4つのエレメントに分類する、対話形式の診断ツールである。合計10問（2択×6問、4択×4問）の基本質問で構成される。選択肢の表示順は、ユーザーがパターンを予測できないよう、質問ごとに固定的に定義されている。診断結果が完全に同点となった場合にのみ、ユーザー自身の最終意思を問う追加質問によって最終タイプを決定する。

#### **2. 診断フロー**
1.  **イントロダクション:** 診断の開始を告げる。
2.  **パート1：2軸マトリクス診断（計6問）**
    *   **【火・風 vs 地・水】**を測る2択質問と、**【地・風 vs 火・水】**を測る2択質問を、**交互に**3回ずつ実施する。（合計6問）
3.  **パート2：4択診断（計4問）**
    *   価値観や行動スタイルを問う4択質問を4回実施。
4.  **スコア計算:** 全10問の回答から、各エレメントの最終スコアを算出する。
5.  **勝者判定:** 最終スコアが最も高いエレメントを特定する。
6.  **同点判定:**
    *   もし最高得点のエレメントが複数存在する場合 → **ステップ7**へ。
    *   最高得点のエレメントが一つだけの場合 → **ステップ8**へ。
7.  **パート3：追加質問（タイブレーク）**
    *   同点だったエレメントのみを対象とした、最後の4択の質問を実施する。
8.  **結果表示:** 最終的に決定したエレメントの**名称**（例: "火"）を出力して終了する。

#### **3. データ構造（`data.py`にて定義）**

**3.1. `axis_questions` （2軸質問データ）**
*   **形式:** Pythonの`list`。6つの`dict`要素を含む。
*   **各`dict`のキー:**
    *   `"question"`: 質問文（テキストは別途指定）。
    *   `"choices"`: 選択肢を格納する`list`。
*   **`choices`リスト内の`dict`のキー:**
    *   `"text"`: 選択肢の全文テキスト（別途指定）。
    *   `"type"`: その選択肢が属するグループID（`"hw"`, `"ds"`, `"df"`のいずれか）。
*   **要件:**
    *   リストの先頭から6つの質問は、`hw_vs_ds`軸と`df_vs_hw`軸の質問が交互に並ぶように構成する。
    *   `choices`リスト内の2つの選択肢の並び順は、**質問ごとに異なる順番で定義すること。** 例えば、ある質問では`[hw, ds]`の順、別の質問では`[ds, hw]`の順というように、並びを固定的に、しかし単調にならないように記述する。**プログラム実行時に都度ランダム化する必要はない。**

**3.2. `four_choice_questions` （4択質問データ）**
*   **形式:** Pythonの`list`。4つの`dict`要素を含む。
*   **各`dict`のキー:**
    *   `"question"`: 質問文（テキストは別途指定）。
    *   `"choices"`: 選択肢を格納する`list`。
*   **`choices`リスト内の`dict`のキー:**
    *   `"text"`: 選択肢の全文テキスト（別途指定）。
    *   `"element"`: 対応するエレメント名（`"火"`, `"地"`, `"風"`, `"水"`）。
*   **要件:** `choices`リスト内の4つの選択肢の並び順は、**質問ごとに異なる順番で、固定的に定義すること。** これもプログラム実行時に都度ランダム化する必要はない。

**3.3. `tie_breaker_question` （追加質問データ）**
*   **形式:** Pythonの`dict`。
*   **キー:**
    *   `"question"`: 質問文（テキストは別途指定）。
    *   `"choices"`: 4択の選択肢を格納する`list`。
*   **`choices`リストの形式:** `four_choice_questions`と同様。

#### **4. 中核ロジック（`main.py`にて実装）**

**4.1. 質問表示エンジン**
*   引数として質問データ（`dict`）を受け取る。
*   質問文を表示する。
*   `choices`リスト内の選択肢を、データで定義された通りの順番で、番号付きリスト（1, 2, ...）として表示する。
*   ユーザーからの番号入力を受け付け、選択された選択肢の`"type"`または`"element"`の値を返す。

**4.2. スコアリング・エンジン**
*   **パート1（2軸）のスコア計算:**
    *   6問の回答から、`hw_score`, `ds_score`, `df_score`, `hw_score_2` をそれぞれカウントする（`hw_vs_ds`軸で`hw`を選んだ数が`hw_score`、`ds`を選んだ数が`ds_score`。`df_vs_hw`軸で`df`を選んだ数が`df_score`、`hw`を選んだ数が`hw_score_2`）。
    *   **1票 = 0.51点**として、各エレメントの**基礎スコア**を算出する。
        *   `fire_base = hw_score + hw_score_2`
        *   `wind_base = hw_score + df_score`
        *   `earth_base = ds_score + df_score`
        *   `water_base = ds_score + hw_score_2`

*   **パート2（4択）のスコア計算:**
    *   4問の回答から、各エレメントの得票数をカウントする。
    *   **1票 = 1点**として、**価値観スコア**を算出する。
        *   `value_score = (得票数) * 1`

*   **最終スコアの計算:**
    *   `final_score = base_score + value_score` を各エレメントで行う。

**4.3. 勝者判定ロジック**
*   `final_scores`の中から最大値を特定する。
*   最大値を持つエレメントを全てリストアップする。
*   リストの要素数が1つなら、それが最終的な勝者となる。
*   リストの要素数が2つ以上なら、同点と判定し、タイブレーク処理を呼び出す。

**4.4. タイブレーク・ロジック**
*   同点だったエレメントのリストを受け取る。
*   `tie_breaker_question`をユーザーに提示する。
*   ユーザーが選んだ選択肢に紐づくエレメントを、最終的な勝者として返す。